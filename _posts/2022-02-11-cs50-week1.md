---
layout: post
title: CS50 week 1
date: 2021-12-29 18:32:24.000000000 +08:00
tags: [cs, cs50]
---

学位一直都是我心里不敢提的伤痛，虽然现在职业发展不错，但是还是不太敢直面自己的伤口，虽然自己很明白一纸学位并不代表什么，但是自己始终没有这张纸。所以一直就有想法考一个真正的学位，不是我花一两万然后在深大那种地方搞个所谓的成人教育本科，搞个学位证，然后又怎样？自己知道也明白，别人也知道明白，这纯粹是一张纸，花这些钱这些时间并没有学到了什么，我数学不好依然不好，我算法不懂依然不懂，计算机基础不行依然不行，所以我花了两年时间搞了一张纸，一张自欺欺人的所谓学位证书。经过自己这么些年的发展，深深的明白一个道理，有没有这张纸其实问题不大，重要的是自己是不是懂的。就像他们说学任何乐器建议从钢琴学起，因为钢琴是基本功，就像学乒乓球要从普通的正手攻球开始学期，就像学篮球要认真学习运球开始，要在这一行走得更远更高，也需要扎实的基本功，因此相对于考个证书，我现在更加明白学习基本功是更加重要的一个事情， 因此有了这个开篇。

我开始在网上搜索怎样自学CS，有一堆的经验跟教程，朋友建议从 CSAPP 开始，我确实看了，但是看了前两章就撑不下去了，根本看不下去。然后意外的发现了哈佛的 [CS50 Introduction to Computer Science](https://www.edx.org/course/introduction-computer-science-harvardx-cs50x), 这个才是自己能跟下去的开篇，因此这就是第一篇记录，或者可以称之为观后感。

David 老师不愧是名校名师，用一堆灯泡解释了二进制的概念和换算，记得去年表弟问我怎么理解二进制跟 ASCII 的时候，我还解释的很牵强。

为什么要二进制，因为电子的世界只有两种状态，开或者关，那对应的就是1或者0，因此只能使用二进制来表示电子世界的状态信息。二进制一个位叫做 bit

那为什么有 ASCII 呢，因为计算机只能由0和1，那要表示人类的表达方式，比如52个大小写字母，10个阿拉伯数字，标点符号等等，ANSI就拟定了这么一套规则，比如说十进制的65表示大写字母 A，相对应的二进制数字就是 100 0001，十进制的66表示大写字母B，对应的二进制数字就是 100 0010。这样用126个十进制数字来表示不同的字符，计算机的世界才能实现人类的表达方式

课程首先解释了什么是 computer science, 原文是这样写的

> Computer science is fundamentally problem solving.
> 

CS 基本上就是解决问题的一套科学，我本来想翻译成方法论，但是想想算法好像更适合方法论这个词。课程上有一张图，将 CS 很具体的表示成了 输入⇒ 处理 ⇒ 输出，David 认为 CS 就是解决中间处理的问题。那计算机要怎么表示人类的表达方式呢，基本就是依据上面提及的 ASCII，但是它怎么工作呢，就是人为的将一个字母表示成8个 bit，称之为一个 byte, 因此当我们手机或者电脑上收到一个表情符号，或者信息，基本上就是一串的 byte，然后电脑或者说智能设备再将这些 byte 根据对应的表达方式转换成我们人类能识别的语言。

那电脑又怎么表示图片呢，相信大家都听过 RGB，就是三颜色，红绿蓝，只要根据不同方式混合这三种颜色就能获得人类想要的其他颜色。人类将十进制数字72，73 跟 33 定义为这三种颜色的不同深浅，就能获得一个新的颜色，每个十进制数字是一个 byte，就有 2 的 8 次方种表达方式，因此三个这样的 byte 就能表达数以万计的数字。然后图片其实就是由很多的 pixel 组成，每一个 pixel 就是图片里的一个小点，这个小点负责表示自己的颜色，根据不同的小点不同的颜色就形成了我们看到的图片了。

好了，解释了计算机怎么表达之后，就开始介绍中间处理的部分，这里开始引入了我们伟大的算法。以前凯文老师告诉我好几次，算法其实没那么复杂，只是处理问题的步骤而已，但是我已经不敢去碰它，因为我深知自己的数学细胞并不发达，好吧，现在看来我只是被中文译名给唬住了。让我们看看 algorithm 的意义是什么, 查自牛津词典的解释

> a process or set of rules to be followed in calculations or other problem-solving operations, especially by a computer.
> 

process, set of rules，只是一堆规则或者流程，用于干嘛？ calculations or other problem-solving operations，所以就是 David 老师所说的用于解决问题的步骤或者方法。这里他还用了一个例子来解释，比如说要在一个电话本里查询一个人的联系信息，怎么查呢？

比如说查一个叫 John 的人，那最简单直接的方式就是我从第一页开始找，一页一页的找下去，只要这个电话本是固定厚度的，总有找到的一天。但是这样的方式是正确却不是有效的，那怎样提高效率呢？我把每一页变成每两页可以吗，还是从第一页开始查，但是我每两页查，这样确实是提高效率了，但是有计划出错，因为万一 John 这个人在偶数页，那我们就查不到了，因为我们每两页会跳过所有的偶数页。 那怎样提高效率呢，有人说可以从中间开始，假设电话本是按照字母顺序排列好的，那我们从中间开始比如说中间是 N，那我翻到中间，然后发现 J 其实在 N 的左边，那就可以直接将 N 的右边的部分丢掉了，因为 John 肯定不会在右边的部分吗，这样不就把问题的复杂度减少了一半嘛，然后在剩下的左边的一半再跳一次，又跳到左边的中间，比如说 H，好了，现在发现 J 在 H 的右边，那又可以丢掉 H 左边了，这样问题的复杂度又减少了一半，然后再继续跳下去，这样只要有 John 这个人，总会找到他的信息而且效率比逐页逐页查高多了。

上面使用的方法就可以称之为算法， Algorithm。 其实并不难理解，不是吗？

然后他介绍了 scratch 并使用 scratch 介绍了一些伪代码并带出了抽象的概念， 怎样使用 scratch 这里就不介绍了，第一次课至少有了跟清晰的开始，明白了一些之前一知半解的东西，也开始真正的认识所谓的算法。

希望我能坚持完成这整个课程，最后贴上这个课程的记录链接：

[CS50 Notes](https://cs50.harvard.edu/x/2021/notes/0/)
