---
layout: post
title: Django之 URLconf
date: 2018-05-20 22:26:24.000000000 +09:00
---

前面一篇文章大致介绍了 django 和一个 django 项目的框架，现在这篇文章主要聊聊 urls.py 的用途了。首先翻译一段来自 [官方文档](https://docs.djangoproject.com/en/2.0/topics/http/urls/) 关于django如何根据url处理一个请求的文字：

> 1. Django首先需要确定哪个是根 URLconf , 这个本来应该是来自项目下面的 settings.py 的定义。但是如果用户的请求里有自定义的 URLconf （通常是由中间件添加的），则这个自定义的值会被当为根 URL 去处理。
>
> 2. Django 加载这个模块，并寻找模块里面的 urlpatterns 的列表，这要不是 django.urls.path() 就是 django.urls.re_path() 组成的列表。两者的区别是 re_path() 支持正则表达式
>
> 3. Django 按照顺序读取列表里的每一个值并逐个匹配用户的请求 URL ， 直到匹配到为止 。
>
> 4. 一旦 Django 找到匹配的值，则加载并调用相对应的模块来相应用户的请求。而且会给这个模块传递下列参数：
>
>    4.1 一个 HTTPRequest 实例
>
>    4.2 如果匹配到的 URL 地址是无名正则分组，则返回对应的分组内容
>
>    4.3 如果是命名正则分组，则根据对应的变量名称返回内容
>
> 5. 如果没有匹配到或者说匹配的过程中发现例外情况，则会触发一个预定义的一个错误处理模块。

让我们先看回 settings.py 里关于 URLconf 的内容：

`ROOT_URLCONF = 'projectName.urls'`

这里就告诉了哪里存放着我们根的 URLconf 了，然后根据这个值去加载根的 URL 解析规则。<u>其实这里我有点不解，就是为什么这里可以直接写 projectName.urls 而不需要写全路径，为什么后面的 Templates 里面的 DIRS 却要写明全路径 ？等我哪天找到这个问题答案再回来补全。</u>

```python
1	urlpatterns = [
2	    re_path(r'^$', views.application),
3	    re_path(r'admin/$', admin.site.urls),
4	    re_path(r'blog/$', views.application),
5	    re_path(r'article/(\d{4})$', views.year),
6	    re_path(r'(?P<year>\d{4})(?P<month>\d{,2})$', views.new),
7	    re_path(r'^article/(?P<year>\d{4}/(?P<month>\d{2}))$', views.year),
8	    re_path(r'registers', views.register, name="reg"),
9	    re_path(r'^article/\d{4}/(?P<month>\d{2})/$', views.year, {"day": 31}),
10	    re_path(r'^article/\d{4}/(?P<month>\d{2})/$', include(views.year), {"day": 31}),
11	    re_path(r'form\d+$', include(views.urls)),
12	]
```

这里就是一个 urlpatterns 的写法了，其实就是 python 的一个 list . Django 根据定义找到这里后，就从第2行开始，按照顺序逐一匹配用户的请求 url , （注意，前面的数字顺序是我自己加上的，真实的环境里是没有的）首先这里使用了 re_path 主要是为了使用正则，如果不要正则也可以用 path , 但是使用正则可以减少我们很多麻烦，比如说我可能用户列表有几十上百号用户，用户的详细信息的url可能是www.example.com/user1/ ， 第二号用户可能是www.example.com/user2/ ，第三的可能是www.example.com/user3/ ，这样下去我不使用正则，那有一千个用户就要写一千行，这样对于开发人员来说累还不说，效率还地下，万一用户的链接改了，可能就要牵扯到成百上千行的修改。因此我是强烈建议使用正则啊，像这种情况使用正则只要写一行就够了

`re_path(r'^user\d+$', views.user),`

这样不管多少用户都可以匹配到了，就算链接需要更改也只要改这一行。

先看第二行， 这是一个默认的相应规则，也就是说通常来说我们使用www.example.com去访问example网站，这样就匹配到了第二行，也就是我们通常的首页。后面再根据不同的应用去匹配不同的规则。

另外呢，就说到了正则的分组了。看第5第6行，有一个共同点就是正则都是写在一对小括号里面的，这个的意思就是把括号里面的正则匹配到的内容作为变量传递到对应的视图去，视图如何接收这个变量我们改天细说。但是这里有个区别就是第六行的小括号里面多了一个 `?P<year>` 和 `?P<month>` ，这个就是所谓的命名分组了。其实呢，命名分组跟无名分组在这里是一样的， 正则还是会去抓取匹配到的内容并传递给后面的视图模块，但是无名分组传到视图是按照顺序来传的，也就是谁在前，那视图里接收的变量就得是在前面;而命名分组则可以在视图里根据 URL 这里的命名来获取变量的内容，所以这两个尖括号里的名字就是这个命名分组的名字。

这里呢，还有一个问题，就是传过来的 url 的合法合规性检查。比如说我要传一个2位数月份，那按照尝试，月份的组成如果第一个数字是0,则后面可以是1到9,如果第一个数字是1,则后面的数字可能是0,1,2三个。所以如果我们写 `\d{2}` ,这样子很粗暴的去匹配两位的数字，是可以，但是如果传过去的是13或者20,那后端的数据肯定不会有第13个月或者第20个月的数据啊，除非你的数据库出问题了，要不这个错误就拖到了后端了。秉着越早发现越早解决效果越好的原则，我们可以把正则修改成这样 `(0[1-9]|1[0-2])` ， 这样就可以正确的匹配到正常的月份了，也就避免了给后端添加麻烦。当然有时候可能没办法匹配到非常准确，在后端添加判断逻辑也无可厚非，而且有时候后端并非一定会通过这个 url 去调用，可能是模块之间直接调用，那这时候后端的判断就很重要了。

看第七行，还有一个分组嵌套的例子。对于这一行如果用户输入2012/12的话，那第一个分组匹配到的就是2012/12,这个作为我们这个例子的year传给后端，然后12作为第二个分组匹配到的内容作为month变量的内容传给后端。

然后看第八行，跟前面有点不一样的地方就是这一行后面多了一个 `name='reg' `, 这个其实是给这个 url  设置一个别名，这样别的模块或者模板要调用的时候可以通过别名调用，避免了 url 一改动就牵一发动全身的时候。

还有第九行，后面对了一个 python 的字典，其实就是给后端传自定义的参数，匹配到这个规则的时候会给后端传递一个名为day的变量，变量的内容为31 ， 这就是额外参数的传递方法 。 但是看第十行这里，也是传额外的自定义参数，但是传给后端是一个 include , 这时 django就会去找 include 的这个模块里面的 urlpatterns , 但是要注意的是，不管这个 urlpatterns 里面有多少行，每一行都会给传递到同一个参数。

接着看第十一行，这里有一个 include 关键字，表示只要匹配到的规则是 form后面接着数字的，就都跳到 views.urls 那里去，这样其实就是一个分层的概念，一级目录的层次在根URLConf里解析，后面对应应用的 URL 解析就都到各自的 urls 里面去解析了 ，解析规则跟我们前面聊得一样。这样就比较好的分开了各个层级，避免了在根 URLConf 里添加了太多的规则，拖慢解析速度，也增加了维护的复杂度。

最后说一下这个URL匹配到底是针对什么的，很多时候我们的 URL 是很复杂的比如 www.example.com/a=12&v=23 这样子，但是要知道，后面的a=12&v=23 其实就是一个 HTTP 的请求方法，比如说 GET , POST等等。但是我们的匹配是不管这些的，也就是说可以看成匹配整个地址从开始到最后一个斜杆为止。

这个就先说这么多了，其实这个官网里关于 URLConf 的用法还有很多，但是很多都不会经常用上，等以后用上了再来补充。

